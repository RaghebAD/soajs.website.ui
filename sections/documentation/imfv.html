<a id="imfv"></a>
<h1>IMFV</h1>
<div class="white-container">
    <p>
	    <b>SOAJS</b> is equipped with an input mapping, filtering and validating mechanism that removes up to 50% of an API code in terms of fetching and cleaning the inputs from POST, GET, SESSION, COOKIES, HEADERS and TENANT CONFIG.<br /><br />

	    <img ng-src="images/documentation/service-folder-tree.png" align="right" style="margin-left:5px; margin-bottom:5px;" class="image-border"/>
	    Every service uses the <b>IMFV</b> (input mapping, filtering and validating) to validate the inputs (parameters) of its APIs. <b>IMFV</b> is usually located in a <u>config.js</u> file within the service directory. The content of this file is based on two main sections:
	    <b>Error Codes</b> ("errors" object) and <b>Validation Schema</b> ("schema" object).
	    <pre><code class="javascript">//inside config.js
module.exports={
	"errors": {},
	"schema": {}
}</code>
		</pre>
    </p>
	<hr/>
	<h3>Error Codes</h3>
	<p>
		<b>Error Codes</b> is a list that contains all the errors that might be returned by the service APIs. Each Error consists of a number referred to by code and an error message.
		<pre><code class="javascript">"errors":{
	//...
	401: "unable to login, user not found!",
	402: "Invalid username provided!"
	//...
}</code>
		</pre>
		When an error in the service occurs, the service will return back to the user a code and a message for clarification.
		To use the error codes inside the service code <u>index.js</u>, use <b>req.soajs.buildResponse</b> and provide the error object as the first parameter. The error object is constructed from the code and the message.
		<pre><code class="javascript">//inside index.js
var config = require("./config");
var service = new soajs.server.service(...);
service.post("/login", function(req, res) {
	//...
	if(req.soajs.inputmaskData.username === ''){
		return res.jsonp(req.soajs.buildResponse({"code": 402, "msg": config.errors[402]}));
	}
	//...
};
		</code></pre>
		<b>SOAJS</b> built-in <b>buildResponse</b> takes 2 parameters, the first being an error object and the second being the response. In most cases, when there is no error, there is a response and vise-versa.<br /><br />
	</p>
	<hr/>

	<h3>Sample Schema</h3>
	<p>
		Every API has an entry inside the schema object; this is where you configure the inputs that it should receive and their validation.
		Every entry instructs <b>IMFV</b> where to look for the input using the source attribute and how to validate the input using the validation attribute.
		<div ng-init="loadCode(path + 'imfv/simple.js', 'simple');">
			<div id="simple"></div>
		</div>
		The above sample Tells <b>IMFV</b> that for API <b>"/testGet"</b> there is a <u>required</u> input called <b>"firstName"</b>.
		It's type is <u>string</u> and it has a specific <u>alphanumeric format</u> and it is provided via the <u>query string</u> as <b>"firstName"</b> when the request is made.<br /><br />
	</p>
	<hr/>
	<h3>Sources List</h3>
	<p>
		<b>IMFV</b> can fetch an input from different sources if configured to do so. In the case above, the "source" array has only one entry which is <b>"query.firstName"</b>. However, you can configure <b>IMFV</b> to look in multiple sources for the input. If the first source doesn't contain the input value, <b>IMFV</b> will jump to the next one and so on till the entire "source" array has been processed.
		<pre><code class="javascript">"firstName" : {
		"source": ["query.firstName", "body.firstName", "session.firstName", ...]
}</code></pre>
	<em>IMFV will look for "firstName" in the following sources, in this order: query string, then posted body, then session... </em>
	</p>
	<hr/>
	<h3>Default Values</h3>
	<p>
		<b>IMFV</b> offers the ability to provide a default value for an input. This means that if the input is not provided, <b>IMFV</b> will use the default value configured for that input.
		<pre><code class="javascript">//...
"firstName": {
	"source": ['query.firstName'],
	"required": true,
	"default": "John",
	"validation": {
		"type": "string"
	}
},
//...
</code></pre>
		The above code sets the value of <u>firstName</u> to <b>"John"</b>. If the request is made to the API without specifying a <u>firstName</u> in the <u>querystring</u>, then <b>req.soajs.inputmaskData.firstName</b> will be set to <b>John</b>.<br /><br />
	</p>
	<hr/>
	<h3>Types, Properties & Formats</h3>
	<p>
		<b>IMFV</b> supports different input types with different properties such as <u>strings</u>, <u>numbers</u>, <u>boolean</u>, <u>arrays</u>, <u>objects</u>, <u>regular expressions</u>... etc. Each of these types has different combination of properties. A <u>string</u> for example can represent an email, a name, a date or a phone number. Here is a list of what can be used with <b>IMFV</b>:
	</p>
	<p>
		<u>Boolean:</u> either true or false.
		<pre><code class="javascript">"married": {
	"source": ['query.married'],
	"required": true,
	"default": false,
	"validation": {
		"type": "boolean"
	}
}</code>
		</pre>
	</p>
	<p>
		<u>regexp:</u> represents a regular expression. <u>Ex:</u> /^\/admin\/.+/$
		<pre><code class="javascript">"route": {
	"source": ['body.route'],
	"required": true,
	"validation": {
		"type": "regexp"
	}
}</code>
		</pre>
	</p>
	<p>
		<u>number:</u> represents both integers and floats.
		<pre><code class="javascript">"price": {
	"source": ['body.route'],
	"required": true,
	"validation": {
		"type": "number",
		"minimum": 0,   //optional
		"maximum": 15.4 //optional
	}
}</code>
		</pre>
	</p>
	<p>
		<u>object:</u> this input can hold different properties from all mentioned types.
		<pre><code class="javascript">"profile":{
	"source": ['body.profile'],
	"validation":{
		"type":"object",
		"properties":{
			"age": { "type": "number", "minimum": 18 },
			"gender": {"type":"string", "enum": ["male","female"]},
			"images": {"type":"string", "format":"uri"},
			"additionalProperties": false
		}
	}
}</code></pre>
	<em>When the type is "array", define what is the type of the items in the array under "items".</em>
	</p><br>
	<p>
		<u>array:</u> this input can hold different items from all mentioned types, each item can have any type mentioned.
		<pre><code class="javascript">"users":{
	"source": ['body.users'],
	"validation":{
		"type":"array",
		"items":{
			"type":"object",
			"properties":{
				"name": { "type": "string", "minLength": 6 },
				"age": { "type": "number", "minimum": 18 },
				"gender": {"type":"string", "enum": ["male","female"]},
				"images": {"type":"string", "format":"uri"},
				"additionalProperties": false
			}
		},
		"minItems": 1, //optional
		"maxItems": 10000, //optional
		"uniqeItems": true, //optional
		"additionalItems": false //optional
	}
}</code>
		</pre>
	</p>
	<p>
		<u>string:</u> can have multiple formats applied to it.
		<pre><code class="javascript">"username":{
	"source": ['body.username'],
	"validation":{
		"type":"string",
		"minLength": 10, //optional
		"maxLength": 20, //optional
		"format": "alphanumeric" //optional
	}
}</code>
		</pre>
		<p>
			When dealing with strings, keep in mind that a string can represent several types of inputs and thus this type is commonly used when providing an api with parameters. Therefore a format option has been added to validate the content of a string and determine if the value resembles the expected outcome. Here is a list of the provided formats that can be used:
		</p>
		<table class="mytable" width="100%">
			<thead>
				<tr>
					<th>Format</th>
					<th>Sample</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>date:</td>
					<td>0000-00-00</td>
				</tr>
				<tr class="even">
					<td>time:</td>
					<td>00:00:00</td>
				</tr>
				<tr>
					<td>date-time:</td>
					<td>0000-00-00T00:00:00.000Z</td>
				</tr>
				<tr class="even">
					<td>route:</td>
					<td>/service/api/pathparam</td>
				</tr>
				<tr>
					<td>phone:</td>
					<td>+(000)-000-0000</td>
				</tr>
				<tr class="even">
					<td>email:</td>
					<td>me@domain.com</td>
				</tr>
				<tr>
					<td>ip-address:</td>
					<td>127.0.0.1</td>
				</tr>
				<tr class="even">
					<td>ipv6:</td>
					<td>FE80:0000:0000:0000:0202:B3FF:FE1E:8329</td>
				</tr>
				<tr>
					<td>uri:</td>
					<td>http://someurl.com/somepath/somenode</td>
				</tr>
				<tr class="even">
					<td>domain:</td>
					<td>someurl.com</td>
				</tr>
				<tr>
					<td>hostname:</td>
					<td>someurl</td>
				</tr>
				<tr class="even">
					<td>alpha:</td>
					<td>John</td>
				</tr>
				<tr>
					<td>alphanumeric:</td>
					<td>John179</td>
				</tr>
				<tr class="even">
					<td>color:</td>
					<td>blue</td>
				</tr>
				<tr>
					<td>style:</td>
					<td>background-color:red</td>
				</tr>
			</tbody>
		</table>
	</p>
	<br />
	<hr/>
	<h3>Type Casting</h3>
	<p>
		<b>IMFV</b> supports all inputs provided if the request headers states that it hold a "content-type" of value "application/json". This means that the arriving input is a JSON input and do not need to apply type casting on them. Any request that does not contain this header, will provide the inputs as strings and therefore these inputs need to be parsed before validation otherwise they will all fail.
		continue here ...
	</p>
	<br />
	<hr/>
	<h3>Complex Schemas</h3>
	<p>
		<b>IMFV</b> supports complex schemas such as arrays and objects, where each of the two contains basic or even more complex schemas internally. It relies on <a href="http://json-schema.org/documentation.html" target="_blank">JSON Schemaâ€™s</a> operator such as <a href="http://json-schema.org/example2.html" target="_blank">oneOf</a>, <a href="http://json-schema.org/example2.html" target="_blank">anyOf</a>, <a href="http://json-schema.org/example2.html" target="_blank">allOf</a> in the cases where the same input might have different values.<br />
		<b>IMFV</b> also uses <a href="http://json-schema.org/example2.html" target="_blank">additionalProperties</a> and <a href="http://json-schema.org/example2.html" target="_blank">patternProperties</a>, from <a href="http://json-schema.org/latest/json-schema-validation.html" target="_blank">JSON Schema</a>, within object schemas giving you validation control on optional api fields and complex input names such as api routes.
		<div ng-init="loadCode(path + 'imfv/advanced.js', 'advanced');">
			<div id="advanced"></div>
		</div><br /><br />
	</p>
	<hr/>
	<h3>Common Fields</h3>
	<p>
		<b>commonfields</b> is used in <b>IMFV</b> to group inputs that have similar mapping and validation. Consider you have 2 or more APIs that use the same input <b>"firstName"</b> and this input is read and validate the same way across those APIs. To avoid rewriting the configuration and make room for errors, add the input under <b>commonFields</b> then in every API configuration, reference its presence.
	<div ng-init="loadCode(path + 'imfv/commonFields.js', 'commonFieldsFull');"></div>
		<div id="commonFieldsFull"></div>
	</p>
	<hr/>
	<h3>Usage</h3>
	<p>
		<b>IMFV</b> consolidates all inputs after validation inside <b>req.soajs.inputmaskData</b> making it easier for developers to use them. Instead of wondering if the input was mapped correctly from the request, simply use <b>req.soajs.inputmaskData</b>[input_name] to retrieve the input value and use it in the code.
		<pre><code class="javascript">//inside index.js
var config = require("./config");
var service = new soajs.server.service(...);
service.post("/login", function(req, res) {
	//...
	if(req.soajs.inputmaskData.username === ''){
		return res.jsonp(req.soajs.buildResponse({"code": 402, "msg": config.errors[402]}));
	}
	//...
};
</code></pre>
		As illustrated in the above code, regardless of the source that provided it, <u>username</u> input can now be accessed from <b>req.soajs.inputmaskData</b> object. The same applies to all other inputs passed to the requested API.<br /><br />
	</p>
	<hr/>
	<h3>Full Sample</h3>
	<p>
		The following is a snippet of both <u>config.js</u> and <u>index.js</u> used together to implement a service that is built with <b>SOAJS</b>; it focuses on how to use the errors and <b>IMFV</b> schema validation.<br /><br />
	</p>
	<tabset>
		<tab heading="Service Index">
			<div ng-init="loadCode(path + 'imfv/index.js', 'indexjs');"></div>
			<div id="indexjs"></div>
		</tab>
		<tab heading="Service Config">
			<div ng-init="loadCode(path + 'imfv/complete.js', 'complete');"></div>
			<div id="complete"></div>
		</tab>
	</tabset>
</div>
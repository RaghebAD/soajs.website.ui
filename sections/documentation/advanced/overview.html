<a id="features-overview"></a>
<h1>Features Overview</h1>
<div class="white-container">
	<p>
		SOAJS gives you the ability to have the same services serve multiple tenants where each tenant can provide its own configuration. The service does not need to be rewritten, and its code needs no updating when you want to provide access to new tenants to use this service. This is very useful when you have multiple clients requesting the same features in their products; write the features once and give your clients access to them. Each client (Tenant) can have his information stored separately and does not affect any of the data of other clients. This approach is known as <a href="#/documentation/advanced/multitenancy">Multitenancy</a>.
	</p>
	<p>
		To achieve multitenancy, the following steps are required:
	</p>
	<ol>
		<li>When you create your <a href="#/documentation/core/service">service</a>, you need to enable multitenant support via SOAJS service constructor.</li>
		<li>You need to productize your service add specify the <a href="#/documentation/core/acl">Access Levels</a> over its APIs in the <a href="#/documentation/advanced/productization">Productization</a> section.</li>
		<li>Create the tenants you want and for each tenant, provide the Productized service to its application.</li>
		<li>Create keys for your tenants applications and add the tenant custom configuration for your service for each key.</li>
	</ol>
	<p>
		Once the above is achieved, all requests made to your service should include the <a href="#/documentation/core/key-security">tenant key</a>. Based on the provided key, SOAJS can load the tenant custom configuration for this service. Then if your tenant has members, these members will inherit the configuration and access levels you specified in the tenant keys and tenant application packages and your service will be apply to serve the different tenants you have and their users accordingly.
	</p>
	<hr/>
	<h3>Create Your Service</h3>
	<p>
		Your service should be created using SOAJS as instructed in the <a href="#/documentation/core/service">Service</a> section under documentation. While declaring your service set it to support multitenancy and access levels.
	</p>
	<pre><code class="javascript">// example of a new service instance with all constructor properties
var myService = new soajs.server.service(config);</code></pre>
	<p>
		The above snippet states that the service supports multitenancy, access levels, persistent sessions and key security. If you are not familiar with this information, checkout <a href="#/documentation/core/service">Service</a> section under documentation.
	</p>
	<p>
		Now let's consider the below API of this service:
	</p>
	<pre><code class="javascript">service.get("/hello", function (req, res) {
	var tenant = req.soajs.servicesConfig.tenantName;
	res.json(req.soajs.buildResponse(null, { tenantName: tenant }));
});

service.get("/ping", function (req, res) {
	var tenant = req.soajs.servicesConfig.tenantName;
	res.json(req.soajs.buildResponse(null, 'hello '+ tenant));
});</code></pre>
	<p>
		The above APIs, check the <b>req.soajs.servicesConfig</b> property to see if it contains an entry for <b>myService</b>. This is how you tell your service to read the custom tenant key configuration from the request made to its API. Having this said, if you have two tenants whose names are: <b>My First Tenant</b> - <b>My Second Tenant</b>, then when the first tenant requests this API, <b>req.soajs.servicesConfig.tenantName</b> will contain <b>My First Tenant</b> and the same applies for tenant two.
	</p>
	<hr/>
	<h3>Productizing The Service</h3>
	<p>
		Now that we have a service and some APIs that handle some requests, let's head on and productize this service. In the Productiztion section, create a product, add a package to it, and tell that package it has access to this service.
	</p>
	<table width="100%" class="myTable">
		<thead>
			<tr>
				<th>Package Name</th>
				<th>Access to myService</th>
				<th>APIs</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>Package 1</td>
				<td>YES</td>
				<td>only API: "/hello"</td>
			</tr>
			<tr class="even">
				<td>Package 2</td>
				<td>YES</td>
				<td>only API: "/ping"</td>
			</tr>
		</tbody>
	</table>
	<p>
		The above product contains 2 packages, the first provides access only to the first API of our service and the second package provides access only to the second API of our service. Refer to <a href="#/documentation/advanced/productization">Productization</a> to learn how a product object will look like in the database and how the packages are added to it and how the ACL is configured and looks like.
	</p>
	<hr/>
	<h3>Multitenancy</h3>
	<p>
		Now we will create some tenants that use the product packages but with different combinations:
	</p>
	<table width="100%" class="myTable">
		<thead>
			<tr class="noBreak">
				<th>Tenant Name</th>
				<th>Application Name</th>
				<th>Package Name</th>
				<th>Overrides Package ACL</th>
				<th>Application Custom ACL</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>T1</td>
				<td>App1</td>
				<td>Package 1</td>
				<td>NO</td>
				<td>N/A</td>
			</tr>
			<tr class="even">
				<td>T1</td>
				<td>App2</td>
				<td>Package 2</td>
				<td>NO</td>
				<td>N/A</td>
			</tr>
			<tr>
				<td>T2</td>
				<td>App1</td>
				<td>Package 1</td>
				<td>YES</td>
				<td>Grants Access to all APIs of myService</td>
			</tr>
		</tbody>
	</table>
	<p>
		The above tenants use the same product differently and thus they interact with the same service differently. The applications of the first tenant have each access to one API in myService only, so if application 2 in tenant 1 attempts to call the other API, it will be blocked.
	</p>
	<p>
		Tenant 2 however is different, it uses the first package which grants access to "/hello" API only but its application overrides the default ACL of the package and grants him access to all the APIs of myService. Tenant 2 can call any API from that package and it will be accepted.
	</p>
	<p>
		Now that we have 2 tenants with 3 applications, let's add the keys and give each key a configuration to provide to myService.
	</p>
	<table width="100%" class="myTable">
		<thead>
			<tr class="noBreak">
				<th>Tenant Name</th>
				<th>Application Name</th>
				<th>Key</th>
				<th>Service Configuration</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>T1</td>
				<td>App1</td>
				<td>Key1</td>
				<td>tenantName: "T1 App1 Key1"</td>
			</tr>
			<tr class="even">
				<td>T1</td>
				<td>App1</td>
				<td>Key2</td>
				<td>tenantName: "T1 App1 Key2"</td>
			</tr>
			<tr>
				<td>T1</td>
				<td>App2</td>
				<td>Key3</td>
				<td>tenantName: "T1 App2 Key3"</td>
			</tr>
			<tr class="even">
				<td>T2</td>
				<td>App1</td>
				<td>Key4</td>
				<td>tenantName: "T2 App1 Key4"</td>
			</tr>
		</tbody>
	</table>
	<p>
		If you are not familiar with tenants, applications, keys or service configurations per tenant, please refer to the <a href="#/documentation/advanced/multitenancy">Multitenancy</a> section under documentation to learn what they mean, where they are located and what their content looks like.
	</p>
	<hr/>
	<h3>Calling the Service</h3>
	<p>
		Let's call the service APIs using the keys from the tables above and see which has access to which API and which service configuration is loaded based on the given key to added in the response of these APIs:
	</p>
	<tabset class="fourTabs">
		<tab heading="Request using Key1">
			<h4>Success Call:</h4>
			<h5>Request:</h5>
			<pre><code class="bash">$ CURL -X GET "http://myService/hello" -H "key:Key1"</code></pre>
			<h5>Response:</h5>
			<pre><code class="bash">{ "result": true, "data": { "tenantName": "T1 App1 Key1" } }</code></pre>
			<br/>
			<h4>Fail Call:</h4>
			<h5>Request:</h5>
			<pre><code class="bash">$ CURL -X GET "http://myService/ping" -H "key:Key1"</code></pre>
			<h5>Response:</h5>
		<pre><code class="bash">{
	"result": false,
	"errors": {
		"codes": [ 154 ],
		"details": [
			{
				"code": 154,
				"message": "Access denied: The service is not available in your current package."
			}
		]
	}
}</code></pre>
			<p>As the table above states, when Key1 is used in the request, its application only has access to /hello API. When requested, the tenantName was retrieved from the configuration of that service and used. However invoke the /ping API of the service didn't work.</p>
		</tab>
		<tab heading="Request using Key2">
			<h4>Success Call:</h4>
			<h5>Request:</h5>
			<pre><code class="bash">$ CURL -X GET "http://myService/hello" -H "key:Key2"</code></pre>
			<h5>Response:</h5>
			<pre><code class="bash">{ "result": true, "data": { "tenantName": "T1 App1 Key2" } }</code></pre>
			<br/>
			<h4>Fail Call:</h4>
			<h5>Request:</h5>
			<pre><code class="bash">$ CURL -X GET "http://myService/ping" -H "key:Key2"</code></pre>
			<h5>Response:</h5>
			<pre><code class="bash">{
	"result": false,
	"errors": {
		"codes": [ 154 ],
		"details": [
			{
				"code": 154,
				"message": "Access denied: The service is not available in your current package."
			}
		]
	}
}</code></pre>
			<p>
				Both Key1 and Key2 use the same application and have access to the same API of myService. Calling /hello API will succeed but calling /ping API will fail. The only difference with between the two keys is the value of <b>tenantName</b> and you can see that in both success calls made to /hello API, the tenantName value is different.
			</p>
		</tab>
		<tab heading="Request using Key3">
			<h4>Success Call:</h4>
			<h5>Request:</h5>
			<pre><code class="bash">$ CURL -X GET "http://myService/ping" -H "key:Key3"</code></pre>
			<h5>Response:</h5>
			<pre><code class="bash">{ "result": true, "data": "Hello T1 App2 Key3" }</code></pre>
			<br/>
			<h4>Fail Call:</h4>
			<h5>Request:</h5>
			<pre><code class="bash">$ CURL -X GET "http://myService/hello" -H "key:Key3"</code></pre>
			<h5>Response:</h5>
			<pre><code class="bash">{
	"result": false,
	"errors": {
		"codes": [ 154 ],
		"details": [
			{
				"code": 154,
				"message": "Access denied: The service is not available in your current package."
			}
		]
	}
}</code></pre>
			<p>
				Key3 was given to Tenant1 Application2 which have the opposite permissions to the first two keys: Key1 and Key2. Also notice that the response is different because API /ping is accessible and its response is not the same as API /hello.
			</p>
		</tab>
		<tab heading="Request using Key4">
			<h4>Success Call:</h4>
			<h5>Request:</h5>
			<pre><code class="bash">$ CURL -X GET "http://myService/ping" -H "key:Key4"</code></pre>
			<h5>Response:</h5>
			<pre><code class="bash">{ "result": true, "data": "Hello T1 App2 Key4" }</code></pre>
			<br/>
			<h4>Success Call:</h4>
			<h5>Request:</h5>
			<pre><code class="bash">$ CURL -X GET "http://myService/hello" -H "key:Key4"</code></pre>
			<h5>Response:</h5>
			<pre><code class="bash">{ "result": true, "data": { "tenantName": "T1 App1 Key4" } }</code></pre>
			<p>
				This key belongs to the first Application of Tenant2 (T2). In the above table we stated that this application uses Package 1 but overrides it's ACL granting access to all APIs of myService. That is why when this key was used, both APIs were accessible and we got a successful response. Also not that the value of <b>tenantName</b> has changed to match the service Configuration tenantName value of Key4.
			</p>
		</tab>
	</tabset>
	<hr/>
	<h3>Multitenancy &amp; Productization at User Level</h3>
	<p>
		So far you have create 1 service with 2 APIs and 2 tenants. There are cases when a tenant has members and one of this tenant's members require special treatment in terms of permissions or service configuration. The remaining members use the tenants permissions and configuration as associated with the key they provide in the headers. In this case, the user that needs the special treatment can override the permissions and/or service configuration of the tenant just like the tenant application overrode the default package permissions in Tenant T2 above.
	</p>
	<p>
		This approach is explained in depth showing how the users records look like and what they contain in the <a href="#/documentation/services/urac">URAC</a> section under documentation. The permissions is also explained in the <a href="#/documentation/core/acl">Access Levels</a> section under documentation.
	</p>
	<table width="100%" class="myTable">
		<thead>
			<tr class="noBreak">
				<th>User</th>
				<th>Tenant Key</th>
				<th>Overrides ACL</th>
				<th>Overrides Service Config</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>Normal User</td>
				<td>Key1</td>
				<td>NO</td>
				<td>NO</td>
			</tr>
			<tr class="even">
				<td>Special User1</td>
				<td>Key1</td>
				<td>YES, can access all APIs of myService</td>
				<td>NO</td>
			</tr>
			<tr>
				<td>Special User2</td>
				<td>Key1</td>
				<td>YES, can access all APIs of myService</td>
				<td>YES, changes tenantName to "Special User2"</td>
			</tr>
		</tbody>
	</table>
	<br/>
	<tabset class="threeTabs">
		<tab heading="Normal User using Key1">
			<h4>Success Call:</h4>
			<h5>Request:</h5>
			<pre><code class="bash">$ CURL -X GET "http://myService/hello" -H "key:Key1"</code></pre>
			<h5>Response:</h5>
			<pre><code class="bash">{ "result": true, "data": { "tenantName": "T1 App1 Key1" } }</code></pre>
			<br/>
			<h4>Fail Call:</h4>
			<h5>Request:</h5>
			<pre><code class="bash">$ CURL -X GET "http://myService/ping" -H "key:Key1"</code></pre>
			<h5>Response:</h5>
		<pre><code class="bash">{
	"result": false,
	"errors": {
		"codes": [ 154 ],
		"details": [
			{
				"code": 154,
				"message": "Access denied: The service is not available in your current package."
			}
		]
	}
}</code></pre>
			<p>This user uses Key1, so definitely the second API /ping is not accessible as we have explained above.</p>
		</tab>
		<tab heading="Special User one using Key1">
			<h4>Success Call:</h4>
			<h5>Request:</h5>
			<pre><code class="bash">$ CURL -X GET "http://myService/hello" -H "key:Key1"</code></pre>
			<h5>Response:</h5>
			<pre><code class="bash">{ "result": true, "data": { "tenantName": "T1 App1 Key1" } }</code></pre>
			<br/>
			<h4>Success Call:</h4>
			<h5>Request:</h5>
			<pre><code class="bash">$ CURL -X GET "http://myService/ping" -H "key:Key1"</code></pre>
			<h5>Response:</h5>
			<pre><code class="bash">{ "result": true, "data": "Hello T1 App1 Key1" }</code></pre>
			<p>
				This user overrides the default ACL of the tenant he uses granting access to all APIs of the service, that is why the second API /ping responded when it was invoked, but notice that the response returned contains the serviceConfig value for tenantName as specified for Key1 in the tenant application.
			</p>
		</tab>
		<tab heading="Special User two using Key1">
			<h4>Success Call:</h4>
			<h5>Request:</h5>
			<pre><code class="bash">$ CURL -X GET "http://myService/hello" -H "key:Key1"</code></pre>
			<h5>Response:</h5>
			<pre><code class="bash">{ "result": true, "data": { "tenantName": "Special User2" } }</code></pre>
			<br/>
			<h4>Success Call:</h4>
			<h5>Request:</h5>
			<pre><code class="bash">$ CURL -X GET "http://myService/ping" -H "key:Key1"</code></pre>
			<h5>Response:</h5>
			<pre><code class="bash">{ "result": true, "data": "Hello Special User2" }</code></pre>
			<p>
				This user overrides both the ACL and service configuration of the tenant it uses. Therefore it was able to access both the APIs and change the value of tenantName in the service configuration.
			</p>
		</tab>
	</tabset>
	<hr/>
	<h3>Summary</h3>
	<p>
		We just showed you how to create a multitenant service, and how to call it from different tenants. We made calls to this service using the different keys we gave to the tenants applications and we saw how the service response was different per key and how some keys have access to one API and others have access to another API. We also mentioned how you can have special users that have custom ACL and configuration.
	</p>
	<p>
		Imagine you have a service that provides both Mail and Calendar Features. Some of your clients purchased a license to use the Mail only while others use the Calendar. Some clients purchased licenses to use both features. Then at a later stage, client 1 that only had access to the Mail feature decides to upgrade and get a new license to use both features. Adding to that, consider that you have clients who dispose of administrator groups and members, so some of their users require additional permissions than the others. All this is achievable using SOAJS, its features allow to accomplish all these scenarios without modifying a single line of code in your service.
	</p>
	<p>
		Now that you know what SOAJS offers you, go ahead and build your <a href="#/documentation/advanced/multitenancy">multitenant</a> services. <a href="#/documentation/advanced/productization">Productize</a> them and offer them to your clients and finally test them in <a href="#/documentation/advanced/environment">multiple environments</a>.
	</p>
</div>